// Source code is decompiled from a .class file using FernFlower decompiler.
package java.io;

import java.util.Iterator;
import java.util.Spliterators;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class BufferedReader extends Reader {
   private Reader in;
   private char[] cb;
   private int nChars;
   private int nextChar;
   private static final int INVALIDATED = -2;
   private static final int UNMARKED = -1;
   private int markedChar;
   private int readAheadLimit;
   private boolean skipLF;
   private boolean markedSkipLF;
   private static int defaultCharBufferSize = 8192;
   private static int defaultExpectedLineLength = 80;

   public BufferedReader(Reader in, int sz) {
      super(in);
      this.markedChar = -1;
      this.readAheadLimit = 0;
      this.skipLF = false;
      this.markedSkipLF = false;
      if (sz <= 0) {
         throw new IllegalArgumentException("Buffer size <= 0");
      } else {
         this.in = in;
         this.cb = new char[sz];
         this.nextChar = this.nChars = 0;
      }
   }

   public BufferedReader(Reader in) {
      this(in, defaultCharBufferSize);
   }

   private void ensureOpen() throws IOException {
      if (this.in == null) {
         throw new IOException("Stream closed");
      }
   }

   private void fill() throws IOException {
      int dst;
      int n;
      if (this.markedChar <= -1) {
         dst = 0;
      } else {
         n = this.nextChar - this.markedChar;
         if (n >= this.readAheadLimit) {
            this.markedChar = -2;
            this.readAheadLimit = 0;
            dst = 0;
         } else {
            if (this.readAheadLimit <= this.cb.length) {
               System.arraycopy(this.cb, this.markedChar, this.cb, 0, n);
               this.markedChar = 0;
               dst = n;
            } else {
               char[] ncb = new char[this.readAheadLimit];
               System.arraycopy(this.cb, this.markedChar, ncb, 0, n);
               this.cb = ncb;
               this.markedChar = 0;
               dst = n;
            }

            this.nextChar = this.nChars = n;
         }
      }

      do {
         n = this.in.read(this.cb, dst, this.cb.length - dst);
      } while(n == 0);

      if (n > 0) {
         this.nChars = dst + n;
         this.nextChar = dst;
      }

   }

   public int read() throws IOException {
      synchronized(this.lock) {
         this.ensureOpen();

         while(true) {
            if (this.nextChar >= this.nChars) {
               this.fill();
               if (this.nextChar >= this.nChars) {
                  return -1;
               }
            }

            if (!this.skipLF) {
               break;
            }

            this.skipLF = false;
            if (this.cb[this.nextChar] != '\n') {
               break;
            }

            ++this.nextChar;
         }

         return this.cb[this.nextChar++];
      }
   }

   private int read1(char[] cbuf, int off, int len) throws IOException {
      if (this.nextChar >= this.nChars) {
         if (len >= this.cb.length && this.markedChar <= -1 && !this.skipLF) {
            return this.in.read(cbuf, off, len);
         }

         this.fill();
      }

      if (this.nextChar >= this.nChars) {
         return -1;
      } else {
         if (this.skipLF) {
            this.skipLF = false;
            if (this.cb[this.nextChar] == '\n') {
               ++this.nextChar;
               if (this.nextChar >= this.nChars) {
                  this.fill();
               }

               if (this.nextChar >= this.nChars) {
                  return -1;
               }
            }
         }

         int n = Math.min(len, this.nChars - this.nextChar);
         System.arraycopy(this.cb, this.nextChar, cbuf, off, n);
         this.nextChar += n;
         return n;
      }
   }

   public int read(char[] cbuf, int off, int len) throws IOException {
      synchronized(this.lock) {
         this.ensureOpen();
         if (off >= 0 && off <= cbuf.length && len >= 0 && off + len <= cbuf.length && off + len >= 0) {
            if (len == 0) {
               return 0;
            } else {
               int n = this.read1(cbuf, off, len);
               if (n <= 0) {
                  return n;
               } else {
                  while(n < len && this.in.ready()) {
                     int n1 = this.read1(cbuf, off + n, len - n);
                     if (n1 <= 0) {
                        break;
                     }

                     n += n1;
                  }

                  return n;
               }
            }
         } else {
            throw new IndexOutOfBoundsException();
         }
      }
   }

   String readLine(boolean ignoreLF) throws IOException {
      StringBuilder s = null;
      synchronized(this.lock) {
         this.ensureOpen();
         boolean omitLF = ignoreLF || this.skipLF;

         while(true) {
            if (this.nextChar >= this.nChars) {
               this.fill();
            }

            if (this.nextChar >= this.nChars) {
               if (s != null && s.length() > 0) {
                  return s.toString();
               }

               return null;
            }

            boolean eol = false;
            char c = 0;
            if (omitLF && this.cb[this.nextChar] == '\n') {
               ++this.nextChar;
            }

            this.skipLF = false;
            omitLF = false;

            int i;
            for(i = this.nextChar; i < this.nChars; ++i) {
               c = this.cb[i];
               if (c == '\n' || c == '\r') {
                  eol = true;
                  break;
               }
            }

            int startChar = this.nextChar;
            this.nextChar = i;
            if (eol) {
               String str;
               if (s == null) {
                  str = new String(this.cb, startChar, i - startChar);
               } else {
                  s.append(this.cb, startChar, i - startChar);
                  str = s.toString();
               }

               ++this.nextChar;
               if (c == '\r') {
                  this.skipLF = true;
               }

               return str;
            }

            if (s == null) {
               s = new StringBuilder(defaultExpectedLineLength);
            }

            s.append(this.cb, startChar, i - startChar);
         }
      }
   }

   public String readLine() throws IOException {
      return this.readLine(false);
   }

   public long skip(long n) throws IOException {
      if (n < 0L) {
         throw new IllegalArgumentException("skip value is negative");
      } else {
         synchronized(this.lock) {
            this.ensureOpen();

            long r;
            for(r = n; r > 0L; this.nextChar = this.nChars) {
               if (this.nextChar >= this.nChars) {
                  this.fill();
               }

               if (this.nextChar >= this.nChars) {
                  break;
               }

               if (this.skipLF) {
                  this.skipLF = false;
                  if (this.cb[this.nextChar] == '\n') {
                     ++this.nextChar;
                  }
               }

               long d = (long)(this.nChars - this.nextChar);
               if (r <= d) {
                  this.nextChar = (int)((long)this.nextChar + r);
                  r = 0L;
                  break;
               }

               r -= d;
            }

            return n - r;
         }
      }
   }

   public boolean ready() throws IOException {
      synchronized(this.lock) {
         this.ensureOpen();
         if (this.skipLF) {
            if (this.nextChar >= this.nChars && this.in.ready()) {
               this.fill();
            }

            if (this.nextChar < this.nChars) {
               if (this.cb[this.nextChar] == '\n') {
                  ++this.nextChar;
               }

               this.skipLF = false;
            }
         }

         return this.nextChar < this.nChars || this.in.ready();
      }
   }

   public boolean markSupported() {
      return true;
   }

   public void mark(int readAheadLimit) throws IOException {
      if (readAheadLimit < 0) {
         throw new IllegalArgumentException("Read-ahead limit < 0");
      } else {
         synchronized(this.lock) {
            this.ensureOpen();
            this.readAheadLimit = readAheadLimit;
            this.markedChar = this.nextChar;
            this.markedSkipLF = this.skipLF;
         }
      }
   }

   public void reset() throws IOException {
      synchronized(this.lock) {
         this.ensureOpen();
         if (this.markedChar < 0) {
            throw new IOException(this.markedChar == -2 ? "Mark invalid" : "Stream not marked");
         } else {
            this.nextChar = this.markedChar;
            this.skipLF = this.markedSkipLF;
         }
      }
   }

   public void close() throws IOException {
      synchronized(this.lock) {
         if (this.in != null) {
            try {
               this.in.close();
            } finally {
               this.in = null;
               this.cb = null;
            }

         }
      }
   }

   public Stream<String> lines() {
      Iterator<String> iter = new 1(this);
      return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iter, 272), false);
   }
}
